---
# 当前页面内容标题
title: Java基础
# 当前页面图标
icon: java
# 分类
category:
  - 计算机
# 标签
tag:
  - java
sticky: false
# 是否收藏在博客主题的文章列表中，当填入数字时，数字越大，排名越靠前。
star: false
# 是否将该文章添加至文章列表中
article: false
# 是否将该文章添加至时间线中
timeline: false
---

# Java

## 1. 入门

### 1.1 cmd命令[^1]

| 操作               | 说明                              |
| ------------------ | --------------------------------- |
| 盘符名称:          | 盘符切换。E:回车，表示切换到E盘。 |
| dir                | 查看当前路径下的内容。            |
| cd 目录            | 进入单级目录。cd itheima          |
| cd ..              | 回退到上一级目录。                |
| cd 目录1\目录2\... | 进入多级目录。cd itheima\JavaSE   |
| cd \               | 回退到盘符目录。                  |
| cls                | 清屏。                            |
| exit               | 退出命令提示符窗口。              |



### 1.2 JDK目录

| 目录名称 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| bin      | 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 |
| conf     | 该路径下存放了JDK的相关配置文件。                            |
| include  | 该路径下存放了一些平台特定的头文件。                         |
| jmods    | 该路径下存放了JDK的各种模块。                                |
| legal    | 该路径下存放了JDK各模块的授权文档。                          |
| lib      | 该路径下存放了JDK工具的一些补充JAR包。                       |



### 1.3 流程

> java文件：程序员自己编写的代码。
>
> class文件：交给计算机执行的文件。

> javac + 文件名 + 后缀名 （就是编译java文件）
>
> java + 文件名（运行编译之后的class文件）



### 1.4 JDK和JRE

> JVM，Java虚拟机
>
> JRE，Java运行环境，包含了JVM和Java的核心类库（Java API）
>
> JDK，称为Java开发工具，包含了JRE和开发工具



### 1.5 Java跨平台原理

- 操作系统本身其实是不认识Java语言的
- 针对不同的操作系统，Java提供了不同的虚拟机。虚拟机会把Java语言翻译成操作系统能看得懂的语言

- 一次编译，处处可用





## 2. 基础语法

### 2.1 注释

```
//				单行注释
/*   */			多行注释
/**  */      	文档注释
```



### 2.2 关键字

| **abstract**   | **assert**       | **boolean**   | **break**      | **byte**   |
| -------------- | ---------------- | ------------- | -------------- | ---------- |
| **case**       | **catch**        | **char**      | **class**      | **const**  |
| **continue**   | **default**      | **do**        | **double**     | **else**   |
| **enum**       | **extends**      | **final**     | **finally**    | **float**  |
| **for**        | **goto**         | **if**        | **implements** | **import** |
| **instanceof** | **int**          | **interface** | **long**       | **native** |
| **new**        | **package**      | **private**   | **protected**  | **public** |
| **return**     | **strictfp**     | **short**     | **static**     | **super**  |
| **switch**     | **synchronized** | **this**      | **throw**      | **throws** |
| **transient**  | **try**          | **void**      | **volatile**   | **while**  |



### 2.3 字面量

整数、小数、字符、字符串、布尔值、空值



### 2.4 变量

```
数据类型 变量名 = 数据值；
```

- 变量名不能重复
- 在一条语句中，可以定义多个变量
- 使用之前必须要赋值



### 2.5 数据类型

- 基本数据类型
- 引用数据类型

| 基本数据类型 | 关键字  | 内存占用 |                 取值范围                  |
| :----------: | :-----: | :------: | :---------------------------------------: |
|     整数     |  byte   |    1     |    负的2的7次方 ~ 2的7次方-1(-128~127)    |
|              |  short  |    2     | 负的2的15次方 ~ 2的15次方-1(-32768~32767) |
|              |   int   |    4     |        负的2的31次方 ~ 2的31次方-1        |
|              |  long   |    8     |        负的2的63次方 ~ 2的63次方-1        |
|    浮点数    |  float  |    4     |        1.401298e-45 ~ 3.402823e+38        |
|              | double  |    8     |      4.9000000e-324 ~ 1.797693e+308       |
|     字符     |  char   |    2     |                  0-65535                  |
|     布尔     | boolean |    1     |                true，false                |

注意[^2]

> 整数类型和小数类型的取值范围大小关系：
>
> double > float > long > int > short > byte



### 2.6 标识符

- 只能由数字、字母、下划线_、美元符号$组成
- 数字不能开头
- 不能是关键字
- 区分大小写

#### 小驼峰命名

> 适用于变量名和方法名，如：name、firstName

#### 大驼峰命名

> 适用于类名，如：Demo、HelloWorld



### 2.7 键盘录入

```java
//1.导包，找到Scanner这个类在哪
import java.util.Scanner;
public class ScannerDemo1{
	public static void main(String[] args){
		//2.创建对象，申明一下，准备开始用Scanner这个类
		Scanner sc = new Scanner(System.in);
		//3.接收数据
		//当程序运行之后，在键盘输入的数据就会被变量i给接收
		System.out.println("请输入一个数字");
		int i = sc.nextInt();
		System.out.println(i);
	}
}
```

#### 进阶

##### 1. next() 和 nextLine()

可以接受任意数据，但是都会返回一个字符串

##### 2. nextInt()

只能接受整数

##### 3. nextDouble()

能接收整数和小数，但是都会看做小数返回

##### 细节

- next（），nextInt（），nextDouble（）在接收数据的时候，会遇到空格，回车，制表符其中一个就会停止接收数据。但是这些符号 + 后面的数据还在内存中并没有接收。如果后面还有其他键盘录入的方法，会自动将这些数据接收。
- nextLine（）方法是把一整行全部接收完毕，想要整数，先接收，再使用Integer.parseInt进行类型转换
- ==以上两套不能混用==





## 3. 运算符与表达式

分类：

````java
+ - * / %
````

> 个位：数字 % 10
>
> 十位：数字 / 10 % 10
>
> 百位：数字 / 100 % 10
>
> 千位：数字 / 1000 % 10



### 3.1 隐式转换

* 取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算。
* byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算。

> 取值范围从小到大
>
> byte short int long float double



### 3.2 强制转换

```java
目标数据类型 变量名 = （目标数据类型）被强转的数据；
```



### 3.3 字符与字符串相加

```java
1 + 2 + "abc" + 2 + 1
// 结果：“3abc21”
    
char c = 'a';
int result = c + 0;
// 结果：97
// 拿着字符到计算机内置的ASCII码表中去查对应的数字，然后再进行计算
```



### 3.4 自增自减运算符

```java
++  自增运算符
--  自减运算符
```



### 3.5 赋值运算符

```java
=	+=	-=	*=	/=	%=
```

扩展的赋值运算符中隐层还包含了一个强制转换

```java
byte a = 10;
byte b = 20;
a += b;
// a = (byte)(a + b);
```



### 3.6 关系运算符

```java
==	!=	>	<	>=	<=	
```

- 关系运算符最终的结果一定是布尔类型的



### 3.7 逻辑运算符

```java
&	|	^	!
```

> 异或（^）：如果两边相同，结果为false，如果两边不同，结果为true
>
> 取反（!）：取反最多只能用一个



### 3.8 短路逻辑运算符

```java
&&	||
```

> 当左边不能确定整个表达式的结果，右边才会执行
>
> 当左边能确定整个表达式的结果，那么右边就不会执行了。从而提高了代码的运行效率



### 3.9 三元运算符

```java
关系表达式 ？ 表达式1 ：表达式2 ；
```

- 三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来



### 3.10 运算符优先级

在Java中涉及了很多的运算符，每一种运算符都有各自的优先级。 

只需知道==小括号优先于所有==





## 4. 流程控制

### 4.1 if语句

```java
格式：
if (关系表达式1) {
    语句体1;	
} else if (关系表达式2) {
    语句体2;	
} 
…
else {
    语句体n+1;
}
```

- 对一个布尔类型的变量进行判断，不要写==，直接把变量写在小括号中即可
- 如果大括号中的语句体只有一条，那么大括号可以省略不写
- 如果大括号省略了，那么if只能控制距离他最近的那一条语句



### 4.2 switch语句

```java
switch (表达式) {
	case 1:
		语句体1;
		break;
	case 2:
		语句体2;
		break;
	...
	default:
		语句体n+1;
		break;
}
```

- default可以放在任意位置，也可以省略
- 不写break会引发case穿透现象
- switch在JDK12的新特性

```java
int number = 10;
switch (number) {
    case 1 -> System.out.println("一");
    case 2 -> System.out.println("二");
    default -> System.out.println("其他");
}
```

> 当我们需要对一个范围进行判断的时候，用if
>
> 当我们把有限个数据列举出来，选择其中一个执行的时候，用switch



```java
利用case穿透简化代码
switch (week){
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        System.out.println("工作日");
        break;
    case 6:
    case 7:
        System.out.println("休息日");
        break;
    default:
        System.out.println("没有这个星期");
        break;
}
----------------------------------------------------
利用JDK12简化代码书写
switch (week) {
    case 1, 2, 3, 4, 5 -> System.out.println("工作日");
    case 6, 7 -> System.out.println("休息日");
    default -> System.out.println("没有这个星期");
}
```





### 4.3 循环语句

#### for

```java
for (int i = 1; i <= 5; i++) {
    System.out.println("HelloWorld");
}
```



#### while

```java
int i = 1;
while(i <= 5){
    System.out.println("HelloWorld");
    i++;
}
```



#### do...while

```java
int i = 1;
do{
    System.out.println("HelloWorld");
    i++;
}while(i <= 5);
```

> 知道循环次数或范围，用for
>
> 不知道循环次数或范围，但是知道循环的结束条件，用while



### 4.4 循环进阶

#### 无限循环

> 初始化语句可以空着不写，表示循环之前不定义任何的控制变量。
>
> 条件判断语句可以空着不写，如果不写，默认表示true，循环一直进行。
>
> 条件控制语句可以空着不写，表示每次循环体执行完毕后，控制变量不做任何变化。

```java
for(;;){
    System.out.println("循环执行一直在打印内容");
}
```

```java
while(true){
    System.out.println("循环执行一直在打印内容");
}
```

```java
do{
    System.out.println("循环执行一直在打印内容");
}while(true);
```



#### 条件控制

- break：不能单独存在。用在switch和循环中，表示结束，跳出
- continue：不能单独存在。只能存在循环中，表示跳过本次循环，执行下次循环



#### Random

```java
//1.导包
import java.util.Random;

public class RandomDemo1 {
    public static void main(String[] args) {
        //2.创建对象
        Random r = new Random();
        //3.生成随机数
        int number = r.nextInt(100);//包左不包右，包头不包尾，[0，100)
        System.out.println(number);

    }
}
```





## 5. 数组

### 5.1 简介

一种容器，可以同来存储同种数据类型的多个值

> 需要结合隐式转换考虑
>
> 定义了一个int类型的数组。那么boolean。double类型的数据是不能存到这个数组中的，但是byte类型，short类型，int类型的数据是可以存到这个数组里面的
>

```java
int [] array; 	
int array [];
int[] agesArr = new int[3];   			// 动态初始化
int[] arr = new int[]{11, 22, 33};
int[] array = {1, 2, 3, 4, 5};			// 静态初始化
```

- 数组一旦创建之后，长度不能发生变化
- 打印数组的时候，实际出现的是数组的地址值[^3]

> [I@6d03e736
>
> [ ：表示现在打印的是一个数组。
>
> I：表示现在打印的数组是int类型的。
>
> @：仅仅是一个间隔符号而已。
>
> 6d03e736：就是数组在内存中真正的地址值。（十六进制的）



==数组默认初始化值==

整数：0	小数类型：0.0	布尔类型：false	字符类型：'\u0000'	引用类型：null



### 5.2 数组元素访问

```java
数组名[索引];
```

- 获取值
- 修改值



### 5.3 索引

一定从0开始、连续不间断、逐个+1增长



### 5.4 遍历

```java
for(int i = 0; i < arr.length; i++){
    sout(arr[i]);
}
```



### 5.5 两种初始化方式

静态初始化：手动指定数组的元素，系统会根据元素的个数，计算出数组的长度。

动态初始化：手动指定数组长度，由系统给出默认初始化值。



## 6. 方法

### 6.1 概述

程序中最小的执行单元



### 6.2 定义与调用

#### 无参数

```java
public static void method (    ) {
	// 方法体;
}
method();
```

#### 有参数

```java
public static void getMax(int num1, int num2){
    ...
}
getMax(10,20);
```

#### 带返回值

```java
public static boolean isEvenNumber( int number ) {           
	return true ;
}
boolean  flag =  isEvenNumber ( 5 ); 
```





### 6.3 实参与形参

- 形参：方法定义中的参数
- 实参：方法调用中的参数



### 6.4 注意事项

- 方法不能嵌套使用
- void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据

```java
 public static void methodOne() {
		public static void methodTwo() {
       		// 这里会引发编译错误!!!
    	}
    }

 public static void methodTwo() {
        //return 100; 编译错误，因为没有具体返回值类型
        return;	
        //System.out.println(100); return语句后面不能跟数据或代码
    }
```



### 6.5 方法重载

- 多个方法在同一个类中
- 多个方法具有相同的方法名
- 多个方法的参数不相同，类型不同或者数量不同

注意：重载仅针对==同一个类==中方法的名称与参数进行识别，==与返回值无关==

```java
public static void fn(int a) {
    	//方法体
    }
public static int fn(int a) { 	/*错误原因：重载与返回值无关*/
    	//方法体
    }


public class MethodDemo01 {
    public static void fn(int a) {
        //方法体
    }
} 
public class MethodDemo02 {
    public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/
        //方法体
    }
}
```



## 7. 面向对象

### 7.1 类

* 属性：在类中通过成员变量来体现（类中方法外的变量）
* 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）

示例：

```java
public class Phone {
    //成员变量
    String brand;
    int price;

    //成员方法
    public void call() {
        System.out.println("打电话");
    }
}
```



### 7.2 对象

使用：

```java
类名 对象名 = new 类名();   // 创建

对象名.成员变量			// 调用
对象名.成员方法();
```

多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份



### 7.3 成员和局部变量

> 1. 成员变量（类中方法外）局部变量（方法内部或方法声明上）
> 2. 成员变量（堆内存）局部变量（栈内存）
> 3. 成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，随着方法的调用完毕而消失）
> 4. 成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）



### 7.4 封装[^4]

>  面向对象三大特征之一[^5]

实现：

成员变量private，提供对应的getXxx()/setXxx()方法

#### private 关键字[^6]

被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作

#### this 关键字[^7]

> 1. 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量
> 2. 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量
> 3. this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。
> 4. this出现在构造方法中，代表构造方法正在初始化的那个对象。





### 7.5 构造方法

作用：创建对象，完成对象数据的初始化 	Student stu = **new Student();**

注意：

> 1. 如果没有定义构造方法，系统将给出一个默认的无参数构造方法
>    如果定义了构造方法，系统将不再提供默认的构造方法
> 2. 如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法
> 3. 无论是否使用，都手工书写无参数构造方法

#### 标准类制作

① 类名需要见名知意

② 成员变量使用private修饰

③ 至少两个构造方法 

* 无参构造方法
* 带全部参数的构造方法

④ 提供每一个成员变量对应的setXxx()/getXxx()

⑤ 其他行为



### 7.6 static 关键字

被static修饰的成员是**属于类**的，放在静态区中随着类的加载而加载的，且只加载一次

没有static修饰的成员变量和方法则是**属于对象**的

```ajva
修饰符 static 数据类型 变量名 = 初始值； 
```

#### 访问

- 有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为**类变量**或者**静态成员变量**。 直接用  类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。
- 无static修饰的成员变量属于每个对象的，  这个成员变量叫**实例变量**，之前我们写成员变量就是实例成员变量。实例成员变量属于每个对象，必须创建类的对象才可以访问。   




### 7.7 继承[^9]

其中，多个类可以称为**子类**，单独被继承的那一个类称为**父类**、**超类（superclass）**或者**基类**。

> 1. 提高**代码的复用性**
> 2. 使类与类之间产生了关系

```java
class 子类 extends 父类 {
	...
}
```

==Java是单继承的，一个类只能继承一个直接父类==



#### 子类继承的内容

1. 子类==不能==继承父类的==构造方法==。

2. 子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过==getter/setter==方法访问父类的private成员变量。



#### 继承后的特点

1. 子父类中出现了同名的成员变量时，子类会优先访问自己对象中的成员变量。如果此时想访问父类成员变量可以使用super关键字[^10]

**使用格式: **

```java
super.父类成员变量名
```

2. 如果子类父类中出现**重名**的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法

3. 构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。
   - 子类构造方法的第一行都隐含了一个**super()**去调用父类无参数构造方法，**super()**可以省略不写。



#### super和this

```java
this.成员变量    	--    本类的
super.成员变量    	--    父类的

this.成员方法名()  	--    本类的    
super.成员方法名()   --    父类的
    
super(...) -- 调用父类的构造方法，根据参数匹配确认
this(...) -- 调用本类的其他构造方法，根据参数匹配确
```

- super() 和 this() 都必须是在构造方法的第一行，所以==不能同时出现==

- 手动调用父类构造会覆盖默认的super()
- super(..)可以调用父类构造方法初始化继承自父类的成员变量的数据



#### 方法重写[^11]

##### @Override重写注解

- 这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。
- 建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错

==注意==

> 1. 方法重写是发生在子父类之间的关系。
> 2. 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。
> 3. 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。



#### 继承特点

1. Java只支持单继承，不支持多继承
  ```java
// 一个类只能有一个父类，不可以有多个父类。
class A {}
class B {}
class C1 extends A {} // ok
// class C2 extends A, B {} // error
  ```

2. 一个类可以有多个子类
  ```java
// A可以有多个子类
class A {}
class C1 extends A {}
class C2 extends  A {}
  ```

3. 可以多层继承
  ```java
class A {}
class C1 extends A {}
class D extends C1 {}
  ```
  > 顶层父类是Object类。所有的类默认继承Object，作为父类。











## 8. 字符串

### 8.1 String[^8]

特点

- 字符串不可变，它们的值在创建后不能被更改
- 虽然 String 的值是不可变的，但是它们可以被共享
- 字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )



#### 常用的构造方法

| 方法名                      | 说明                                      |
| --------------------------- | ----------------------------------------- |
| public   String()           | 创建一个空白字符串对象，不含有任何内容    |
| public   String(char[] chs) | 根据字符数组的内容，来创建字符串对象      |
| public   String(byte[] bys) | 根据字节数组的内容，来创建字符串对象      |
| String s =   “abc”;         | 直接赋值的方式创建字符串对象，内容就是abc |

区别

- 通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同

- 直接赋值的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护




#### 字符串的比较

==号

> - 比较基本数据类型：比较的是具体的值
>
> - 比较引用数据类型：比较的是对象地址值

equals

> - 比较两个字符串内容是否相同、区分大小写



### 8.2 StringBuilder

StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。

在拼接字符串和反转字符串的时候会使用到

基本使用

```java
public class StringBuilderDemo3 {
    public static void main(String[] args) {
        //1.创建对象
        StringBuilder sb = new StringBuilder("abc");

        // 添加元素
        sb.append(1);
        
        // 反转
        sb.reverse();

        // 获取长度
        int len = sb.length();

        // 因为StringBuilder是Java已经写好的类
        // java在底层对他做了一些特殊处理。
        // 打印对象不是地址值而是属性值。
        System.out.println(sb);
        
        // 把StringBuilder变回字符串
        String str = sb.toString();
    }
}
```



### 8.3 StringJoiner

* StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。
* 作用：提高字符串的操作效率，而且代码编写特别简洁
* JDK8出现的

基本使用

```java
//1.创建对象, 指定间隔符号
StringJoiner sj = new StringJoiner(", " , "[" , "]");

//2.添加元素
sj.add("aaa").add("bbb").add("ccc");
int len = sj.length();
System.out.println(len);//15

//3.打印
System.out.println(sj);//[aaa, bbb, ccc]
String str = sj.toString();
System.out.println(str);//[aaa, bbb, ccc]
```





## 9. 集合

### 9.1 ArrayList

#### 概述

- 提供一种存储空间可变的存储模型，存储的数据容量可以发生改变
- 长度可以变化，只能存储引用数据类型
- 用泛型约束集合中存储元素的数据类型

> 1. 长度可变
> 2. 添加数据时不许考虑索引，默认添加到末尾



#### 构造方法

| 方法名             | 说明                 |
| ------------------ | -------------------- |
| public ArrayList() | 创建一个空的集合对象 |

#### 成员方法

| 方法名                                | 说明                                   |
| ------------------------------------- | -------------------------------------- |
| public boolean add(要添加的元素)      | 将指定的元素追加到此集合的末尾         |
| public boolean remove(要删除的元素)   | 删除指定元素,返回值表示是否删除成功    |
| public E  remove(int   index)         | 删除指定索引处的元素，返回被删除的元素 |
| public E   set(int index,E   element) | 修改指定索引处的元素，返回被修改的元素 |
| public E   get(int   index)           | 返回指定索引处的元素                   |
| public int   size()                   | 返回集合中的元素的个数                 |





































[^1]:真正的DOS命令是1981年微软和IBM出品的MS-DOS操作系统中的命令才叫做DOS命令。而在Windows中，win98之前的操作系统是以非图形化的DOS为基础的，可以叫做DOS命令。到了2000年以后，windows逐渐的以图形化界面为主了，这个时候就不能叫DOS命令了，他只是模拟了DOS环境而已，很多的原本的DOS命令已经无法使用了，所以这个时候叫做CMD命令会更准确一些
[^2]:e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。在java中整数默认是int类型，浮点数默认是double类型。
[^3]:数组在内存中的位置

[^4]:将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问
[^5]: 封装，继承，多态
[^6]:private是一个修饰符，可以用来修饰成员（成员变量，成员方法）
[^7]: this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）
[^8]: Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！
[^9]: 就是子类继承父类的**属性**和**行为**，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的**非私有**的属性和行为。
[^10]: 子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用`super` 关键字，修饰父类成员变量，类似于之前学过的this 
[^11]:子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写



